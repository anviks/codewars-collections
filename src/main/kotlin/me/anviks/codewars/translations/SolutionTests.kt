//package me.anviks.codewars.translations
//
//import org.junit.jupiter.api.*
//import org.junit.jupiter.api.Assertions.assertEquals
//import java.util.*
//import java.util.function.IntFunction
//import java.util.concurrent.ThreadLocalRandom
//import java.util.stream.Collectors.joining
//
//
//data class TestCase(val gen: IntFunction<String>, val expected: Boolean)
//
//@TestMethodOrder(MethodOrderer.OrderAnnotation::class)
//class SolutionTests {
//
//    private fun runTest(expected: Boolean, input: String) {
//        assertEquals(expected, validParentheses(input), "Test failed for input \"$input\"")
//    }
//
//    @Nested
//    @Order(1)
//    inner class FixedTests {
//
//        @Test
//        @DisplayName("Should return true for valid parentheses")
//        fun validCases() {
//            runTest(true, "()")
//            runTest(true, "((()))")
//            runTest(true, "()()()")
//            runTest(true, "(()())()")
//            runTest(true, "()(())((()))(())()")
//        }
//
//        @Test
//        @DisplayName("Should return false for invalid parentheses")
//        fun invalidCases() {
//            runTest(false, ")(")
//            runTest(false, "()()(")
//            runTest(false, "((())")
//            runTest(false, "())(()")
//            runTest(false, ")()")
//            runTest(false, ")")
//        }
//
//        @Test
//        @DisplayName("Should return true for empty strings")
//        fun emptyString() {
//            runTest(true, "")
//        }
//    }
//
//    private val rnd: Random = ThreadLocalRandom.current()
//
//    @Nested
//    @Order(2)
//    inner class RandomTests {
//
//        private inner class ParenTree(private val maxChildren: Int, private val root: Boolean) {
//            var left: String
//            var right: String
//            val children: MutableList<ParenTree> = ArrayList()
//
//            /**
//             * Builds a valid parentheses tree of chosen size
//             *
//             * All nodes (except the root node) represent a pair of
//             * parens, potentially with some child pairs between them.
//             *
//             * They are generated by continually generating child nodes until
//             * the desired size is reached, then shuffling the order of the
//             * child nodes.
//             */
//            init {
//                if (root) {
//                    left = ""
//                    right = ""
//                } else {
//                    left = "("
//                    right = ")"
//                }
//                var maxChildCount = maxChildren - 1
//                while (maxChildCount > 0) {
//                    val n = rnd.nextInt(maxChildCount) + 1
//                    maxChildCount -= n
//                    children.add(ParenTree(n, false))
//                }
//                children.shuffle(rnd)
//            }
//
//            constructor(maxChildren: Int) : this(maxChildren, true)
//
//            override fun toString(): String {
//                return left + children.stream().map { it.toString() }.collect(joining()) + right
//            }
//        }
//
//        private val generateBalanced: IntFunction<String> = IntFunction { size -> ParenTree(size).toString() }
//        private val generateEmpty: IntFunction<String> = IntFunction { size -> "" }
//        private val generateUnbalanced: IntFunction<String> = IntFunction { size ->
//            val parens = ParenTree(size).toString()
//            val idx = rnd.nextInt(parens.length)
//            parens.substring(0, idx) + parens.substring(idx + 1)
//        }
//        private val generateUnequal: IntFunction<String> = IntFunction { size ->
//            val parens = ParenTree(size).toString()
//            val idx = rnd.nextInt(parens.length)
//            parens.substring(0, idx) + if (parens[idx] == '(') ')' else '(' + parens.substring(idx + 1)
//        }
//        private val generateSwapped: IntFunction<String> = IntFunction { size ->
//            val parens = ParenTree(size).toString()
//            val target = ParenTree(size).children[rnd.nextInt(ParenTree(size).children.size)]
//            target.left = ")"
//            target.right = "("
//            parens
//        }
//
//        @Test
//        @DisplayName("Small tests")
//        fun smallTests() {
//            val testCases: MutableList<TestCase> = ArrayList()
//            testCases.addAll(Collections.nCopies(2, TestCase(generateEmpty, true)))
//            testCases.addAll(Collections.nCopies(14, TestCase(generateBalanced, true)))
//            testCases.addAll(Collections.nCopies(6, TestCase(generateSwapped, false)))
//            testCases.addAll(Collections.nCopies(4, TestCase(generateUnequal, false)))
//            testCases.addAll(Collections.nCopies(4, TestCase(generateUnbalanced, false)))
//            testCases.shuffle(rnd)
//
//            for (testCase in testCases) {
//                val size = rnd.nextInt(1, 13)
//                val parens = testCase.gen.apply(size)
//                runTest(testCase.expected, parens)
//            }
//        }
//
//        @Test
//        @DisplayName("Large tests")
//        fun largeTests() {
//            val testCases: MutableList<TestCase> = ArrayList()
//            testCases.addAll(Collections.nCopies(25, TestCase(generateBalanced, true)))
//            testCases.addAll(Collections.nCopies(21, TestCase(generateSwapped, false)))
//            testCases.addAll(Collections.nCopies(12, TestCase(generateUnequal, false)))
//            testCases.addAll(Collections.nCopies(12, TestCase(generateUnbalanced, false)))
//            testCases.shuffle(rnd)
//
//            for (testCase in testCases) {
//                val size = rnd.nextInt(35, 50)
//                val parens = testCase.gen.apply(size)
//                runTest(testCase.expected, parens)
//            }
//        }
//    }
//}
