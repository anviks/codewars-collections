package me.anviks.my_translations

import org.junit.jupiter.api.*
import org.junit.jupiter.api.Assertions.assertEquals
import java.util.*
import java.util.function.IntFunction
import java.util.concurrent.ThreadLocalRandom
import java.util.stream.Collectors.joining


data class TestCase(val gen: IntFunction<String>, val expected: Boolean)

@TestMethodOrder(MethodOrderer.OrderAnnotation::class)
class SolutionTests {

    private fun runTest(expected: Boolean, input: String) {
        assertEquals(expected, validParentheses(input), "Test failed for input \"$input\"")
    }

    @Nested
    @Order(1)
    inner class FixedTests {

        @Test
        @DisplayName("Should return true for valid parentheses")
        fun validCases() {
            runTest(true, "()")
            runTest(true, "((()))")
            runTest(true, "()()()")
            runTest(true, "(()())()")
            runTest(true, "()(())((()))(())()")
        }

        @Test
        @DisplayName("Should return false for invalid parentheses")
        fun invalidCases() {
            runTest(false, ")(")
            runTest(false, "()()(")
            runTest(false, "((())")
            runTest(false, "())(()")
            runTest(false, ")()")
            runTest(false, ")")
        }

        @Test
        @DisplayName("Should return true for empty strings")
        fun emptyString() {
            runTest(true, "")
        }
    }

    private val rnd: Random = ThreadLocalRandom.current()

    @Nested
    @Order(2)
    inner class RandomTests {

        private inner class ParenTree(private val maxChildren: Int, private val root: Boolean) {
            var left: String
            var right: String
            val children: MutableList<ParenTree> = ArrayList()

            /**
             * Builds a valid parentheses tree of chosen size
             *
             * All nodes (except the root node) represent a pair of
             * parens, potentially with some child pairs between them.
             *
             * They are generated by continually generating child nodes until
             * the desired size is reached, then shuffling the order of the
             * child nodes.
             */
            init {
                if (root) {
                    left = ""
                    right = ""
                } else {
                    left = "("
                    right = ")"
                }
                var maxChildCount = maxChildren - 1
                while (maxChildCount > 0) {
                    val n = rnd.nextInt(maxChildCount) + 1
                    maxChildCount -= n
                    children.add(ParenTree(n, false))
                }
                children.shuffle(rnd)
            }

            constructor(maxChildren: Int) : this(maxChildren, true)

            override fun toString(): String {
                return left + children.stream().map { it.toString() }.collect(joining()) + right
            }
        }

        private val generateBalanced: IntFunction<String> = IntFunction { size -> ParenTree(size).toString() }
        private val generateEmpty: IntFunction<String> = IntFunction { size -> "" }
        private val generateUnbalanced: IntFunction<String> = IntFunction { size ->
            val parens = ParenTree(size).toString()
            val idx = rnd.nextInt(parens.length)
            parens.substring(0, idx) + parens.substring(idx + 1)
        }
        private val generateUnequal: IntFunction<String> = IntFunction { size ->
            val parens = ParenTree(size).toString()
            val idx = rnd.nextInt(parens.length)
            parens.substring(0, idx) + if (parens[idx] == '(') ')' else '(' + parens.substring(idx + 1)
        }
        private val generateSwapped: IntFunction<String> = IntFunction { size ->
            val parens = ParenTree(size).toString()
            val target = ParenTree(size).children[rnd.nextInt(ParenTree(size).children.size)]
            target.left = ")"
            target.right = "("
            parens
        }

        @Test
        @DisplayName("Small tests")
        fun smallTests() {
            val testCases: MutableList<TestCase> = ArrayList()
            testCases.addAll(Collections.nCopies(2, TestCase(generateEmpty, true)))
            testCases.addAll(Collections.nCopies(14, TestCase(generateBalanced, true)))
            testCases.addAll(Collections.nCopies(6, TestCase(generateSwapped, false)))
            testCases.addAll(Collections.nCopies(4, TestCase(generateUnequal, false)))
            testCases.addAll(Collections.nCopies(4, TestCase(generateUnbalanced, false)))
            testCases.shuffle(rnd)

            for (testCase in testCases) {
                val size = rnd.nextInt(1, 13)
                val parens = testCase.gen.apply(size)
                runTest(testCase.expected, parens)
            }
        }

        @Test
        @DisplayName("Large tests")
        fun largeTests() {
            val testCases: MutableList<TestCase> = ArrayList()
            testCases.addAll(Collections.nCopies(25, TestCase(generateBalanced, true)))
            testCases.addAll(Collections.nCopies(21, TestCase(generateSwapped, false)))
            testCases.addAll(Collections.nCopies(12, TestCase(generateUnequal, false)))
            testCases.addAll(Collections.nCopies(12, TestCase(generateUnbalanced, false)))
            testCases.shuffle(rnd)

            for (testCase in testCases) {
                val size = rnd.nextInt(35, 50)
                val parens = testCase.gen.apply(size)
                runTest(testCase.expected, parens)
            }
        }
    }
}
